/**
 * \addtogroup argParser
 * The Argument Parser can be used to easily parse lists of strings for commands and values
 * @{
 */
 
/**
 * \page page_argParser How to use argParser
 *
 * You need to include this header
 * \code{.cpp}
 * #include "clockUtils/argParser/ArgumentParser.h"
 * \endcode
 *
 * The usage is really simple and contains just two steps:\n\n
 *
 * First you have to register all variables that should be parseable, that means every argument. For this reason there is the macro REGISTER_VARIABLE(type, value, value, description). The four arguments it expects are the type of variable, the name of the variable (to use is in the code and also the string being looked for in the list), a default value and a description for the --help functionality explaining what the variable is good for and what it expects.\n
 * If the variable type contains a ',' (Template class with several parameters) create a simple typedef (C++ Preprocessor requirement)\n\n
 * Example:\n
 * \code{.cpp}
 * REGISTER_VARIABLE(bool, b, false, "a bool value");
 * \endcode
 * This line will give you a bool variable being initialized with false. If the argument -b is found in the argument list, the variable will be set to true. The bool is a special case because it doesn't expect any value!\n\n
 * \code{.cpp}
 * REGISTER_VARIABLE(std::string, s, "english", "a string containing the used language");
 * \endcode
 * This line will give you a std::string variable being initialized with "english". To change the string, there are three possibilities to pass the argument:\n
 * -s german\n
 * -sgerman\n
 * -s=german\n\n
 * The next step is to parse your list. Therefor exist two macros:\n
 * PARSE_COMMANDLINE() parses the arguments of the main method (argc and argv)\n
 * PARSE_ARGUMENTS(buffer, length) parses an own list\n
 * If you use the first one, make sure argc and argv are defined. Furthermore, argv needs to be const.\n\n
 *
 * You can also use the automatically available parameter --help. If --help was entered on commandline, the macro HELPSET() returns true and the text output can be retrieved using GETHELPTEXT()
 * Example:\n
 * \code{.cpp}
 * if (HELPSET()) {
 * 	std::cout << GETHELPTEXT() << std::endl;
 * }
 * \endcode
 * \n
 * In some cases you want to ignore additional entries at the end of the commandline or you want a to support more than one parameter e.g. parsing multiple files. Therefore you can register a std::vector<std::string> using REGISTER_VARIABLE_ARGUMENTS(name) where name is the name of the variable. All additional entries are pushed into this vector and they don't cause an error any more as they did before.
 * Example:\n
 * \code{.cpp}
 * int main(int argc, const char ** argv) {
 * 	REGISTER_VARIABLE_ARGUMENTS(files);
 *	PARSE_COMMANDLINE();
 * }
 * \endcode
 * Calling this main compiles to foobar with "./foobar a b c" results in vector files containing entries a, b and c.
 *
 */
 
/**
 * @}
 */
